#include "main.h"

#include <stdio.h>
#include <stdlib.h>

#include "gba.h"
/* TODO: */
// Include any header files for title screen or exit
// screen images generated by nin10kit. Example for the provided garbage
// image:
// #include "images/garbage.h"
#include "images/buzz.h"
#include "images/garbage.h"
#include "images/bugspray.h"
#include "images/soap.h"
#include "images/startscreen.h"
#include "images/losescreen.h"
#include "images/winscreen.h"

/* TODO: */
// Add any additional states you need for your app. You are not requried to use
// these specific provided states.
enum gba_state {
  START,
  PLAY,
  WIN,
  LOSE,
};
/*
    START -> PLAY
    PLAY -> wait, render screen (player can move around)
    PLAY -> WIN (if collision with end box)
    PLAY -> LOSE (if collision with enemy)
    PLAY -> START (when SELECT/backspace pressed)
*/

struct entity *plr, *enemy1, *soapE, *sprayE, *winArea;
struct state cs, ps;
// int variables for score and timer
int plrWidth = 10;
int plrHeight = 10;

int enemyWidth = 30;
int enemyHeight = 30;
int timerCap = 60; // frame rate is 60 fps, 1/60

int collision(struct entity e1, struct entity e2) {
    return (
        e1.col < e2.col + e2.width && e1.col + e1.width > e2.col
        && e1.row < e2.row + e2.height && e1.row + e1.height > e2.row
    );
}

void checkPlayerInputs(u32 currentButtons) {
    // player button inputs, if out of bounds, just wrap around
    /*
    if (KEY_DOWN(BUTTON_UP, currentButtons)) {
        if (plr->row <= 0) {
            plr->row = HEIGHT - plrHeight;
        } else {
            plr->row -= 5;
        }
    }
    if (KEY_DOWN(BUTTON_DOWN, currentButtons)) {
        if (plr->row >= HEIGHT - plrHeight) {
            plr->row = 0;
        } else {
            plr->row += 5;
        }
    }
    if (KEY_DOWN(BUTTON_LEFT, currentButtons)) {
        if (plr->col <= 0) {
            plr->col = WIDTH - plrWidth;
        } else {
            plr->col -= 5;
        }
    }
    if (KEY_DOWN(BUTTON_RIGHT, currentButtons)) {
        if (plr->col >= WIDTH - plrWidth) {
            plr->col = 0;
        } else {
            plr->col += 5;
        }
    }
    */
    if (KEY_DOWN(BUTTON_UP, currentButtons)) {
        if (plr->row > 0) {
            plr->row -= 1;
        }
    }
    if (KEY_DOWN(BUTTON_LEFT, currentButtons)) {
        if (plr->col > 0) {
            plr->col -= 1;
        }
    }
    if (KEY_DOWN(BUTTON_DOWN, currentButtons)) {
        if (plr->row < HEIGHT - plrHeight) {
            plr->row += 1;
        }
    }
    if (KEY_DOWN(BUTTON_RIGHT, currentButtons)) {
        if (plr->col < WIDTH - plrWidth) {
            plr->col += 1;
        }
    }
}

void initializePlay(void) {
    // initialize starting entity positions

    plr = &cs.plr;
    plr->row = HEIGHT / 2;
    plr->col = 10;
    plr->width = plrWidth;
    plr->height = plrHeight;

    enemy1 = &cs.enemy1;
    enemy1->row = HEIGHT / 2;
    enemy1->col = 160;
    enemy1->width = 50;
    enemy1->height = 37;

    soapE = &cs.soapE;
    soapE->row = HEIGHT / 2 + 20;
    soapE->col = 100;
    soapE->width = enemyWidth;
    soapE->height = enemyHeight;

    sprayE = &cs.sprayE;
    sprayE->row = HEIGHT / 2 - 20;
    sprayE->col = 45;
    sprayE->width = enemyWidth;
    sprayE->height = enemyHeight;

    winArea = &cs.winArea;
    winArea->row = HEIGHT / 2;
    winArea->col = 225;
    winArea->width = 10;
    winArea->height = 10;

    cs.timer = 20;
}

int main(void) {
  /* TODO: */
  // Manipulate REG_DISPCNT here to set Mode 3. //
  REG_DISPCNT = MODE3 | BG2_ENABLE;

  // Save current and previous state of button input.
  u32 previousButtons = BUTTONS;
  u32 currentButtons = BUTTONS;

  // Load initial application state
  enum gba_state state = START;
  // cs.timer = 60;    // current time in seconds

  while (1) {
    currentButtons = BUTTONS; // Load the current state of the buttons
    ps = cs;   // have previous state to undraw
    /* TODO: */
    // Manipulate the state machine below as needed
    // NOTE: Call waitForVBlank() before you draw
    waitForVBlank();  // only call it once per iteration
    switch (state) {
      case START:
        initializePlay();
        // fillScreenDMA(BLACK);  // reset screen, make sure only occurs once
        drawFullScreenImageDMA(startscreen);
        {
        char buffer[51];
        sprintf(buffer, "Press START");
        drawString(150, 5, buffer, BLACK);
        }

        if (KEY_JUST_PRESSED(BUTTON_START, currentButtons, previousButtons))) {
            state = PLAY;
            fillScreenDMA(GREEN);
            // drawFullScreenImageDMA(losescreen);
        }
        break;
      case PLAY:
        // undraw old state
        drawRectDMA(ps.plr.row, ps.plr.col, ps.plr.width, ps.plr.height, GREEN);
        drawRectDMA(ps.enemy1.row, ps.enemy1.col, ps.enemy1.width, ps.enemy1.height, GREEN);
        drawRectDMA(ps.sprayE.row, ps.sprayE.col, ps.sprayE.width, ps.sprayE.height, GREEN);
        drawRectDMA(ps.soapE.row, ps.soapE.col, ps.soapE.width, ps.soapE.height, GREEN);
        
        // undrawImageDMA(ps.enemy1.row, ps.enemy1.col, ps.enemy1.width, ps.enemy1.height, BLUE);

        checkPlayerInputs(currentButtons);

        if (enemy1->row <= 0 - enemyHeight) {  // should be 37 instead (height of logo)
            enemy1->row = HEIGHT;
        } else {
            enemy1->row -= 2;
        }

        if (soapE->row <= 0 - enemyHeight) {
            soapE->row = HEIGHT;
        } else {
            soapE->row -= 3;
        }

        if (sprayE->row <= 0 - enemyHeight) {
            sprayE->row = HEIGHT;
        } else {
            sprayE->row -= 1;
        }

        // draw
        drawRectDMA(plr->row, plr->col, plr->width, plr->height, YELLOW);

        // drawRectDMA(ps.enemy1.row, ps.enemy1.col, ps.enemy1.width, ps.enemy1.height, RED);
        drawImageDMA(enemy1->row, enemy1->col, enemy1->width, enemy1->height, garbage);
        drawImageDMA(soapE->row, soapE->col, soapE->width, soapE->height, soap);
        drawImageDMA(sprayE->row, sprayE->col, sprayE->width, sprayE->height, bugspray);
        drawImageDMA(winArea->row, winArea->col, winArea->width, winArea->height, buzz);

        timerCap--;
        if (timerCap <= 0) {
            timerCap = 60;
            cs.timer--;
            if (cs.timer <= 0) {
                state = LOSE;
                drawFullScreenImageDMA(losescreen);
                break;
            }
        }

        {
        char buffer[51];
        snprintf(buffer, sizeof(buffer), "Timer: %d", ps.timer);
        drawString(150, 5, buffer, GREEN);
        }
        {
        char buffer[51];
        snprintf(buffer, sizeof(buffer), "Timer: %d", cs.timer);
        drawString(150, 5, buffer, BLUE);
        }

        // go back to home page
        if (KEY_JUST_PRESSED(BUTTON_SELECT, currentButtons, previousButtons))) {
            state = START;
        }

        if (collision(*enemy1, *plr) || collision(*soapE, *plr) || collision(*sprayE, *plr)) {
            state = LOSE;
            drawFullScreenImageDMA(losescreen);
        }
        if (collision(*winArea, *plr)) {
            state = WIN;
            drawFullScreenImageDMA(winscreen);
        }

        break;
      case WIN:
        {
        char buffer[51];
        sprintf(buffer, "You won :) press SELECT to retry...");
        drawString(150, 5, buffer, BLUE);
        }
        if (KEY_JUST_PRESSED(BUTTON_SELECT, currentButtons, previousButtons))) {
            state = START;
        }
        break;
      case LOSE:
        {
        char buffer[51];
        sprintf(buffer, "You lost :( press SELECT to retry...");
        drawString(150, 5, buffer, BLUE);
        }
        if (KEY_JUST_PRESSED(BUTTON_SELECT, currentButtons, previousButtons))) {
            state = START;
        }
        break;
    }

    previousButtons = currentButtons; // Store the current state of the buttons
  }

  return 0;
}
